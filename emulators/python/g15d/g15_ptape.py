# borrowed from the main g15 paper format conversion source

##############################################
#
# collections of routines to read/write various G15
# tapes in a variety of formats.
#
# At the start of this endeavor not a lot of G15 programs are
# available.  These routines were created to support the 
# addition of programs/tapes, as they are acquired, and placed
# into the tape "database"
#
# the database is a collection of tapes in PTR format
# (see below).
# 
# In addition, a couple of readers have been built to read
# the paper tapes.
#
# Various scripts have been written to perform tape format
# conversions.  These scripts call this class's methods to
# effect the actual read or writing of a particular format
#
#
###############################################
# sources of paper tapes:
# as of this writing (07/31/2022), tape images have been
# acquired from the following sources:
#
# Australian computer museum (via David Green)
# Living Computer Museum (LCM)
# Pierce Fuller website
# Lloyd Hasley personal collection
#
# each of these sources has "artifacts"/features to be dealt with
# Once dealt with, a "master" PTR file is created and becomes
# the official version
#
# Note: Bendix programs tended to change over time.  We have three
# different versions of test routines 1 & 2.  Very similar, but various
# blocks of tape have been upgraded over time.   Knowledge of which one
# is newest and oldest has long since been lost.  Because of this,
# a tape is prefixed with its source location to keep all the names unique
#
####################################################
#
# Tape formats.
#
# M:	music format
#			each line corresponds to a note(2) in time
#			format:   note1 note2 duration
#			see music program UP41 for note and duration codes
# PT:	binary file, one byte per character on the tape.
#			if generated by this program, proper G15 spacing in corporated
#			(see below)
# PTI:	ascii file, one byte per character on tape, expressed in ascii with
#			bendix control characters also mapped to special ascii characters
#			(This file does not preserve any Bendix timing requirements.)
# PTIR:	ascii file, nearly identical to PTI; but assumes the format produced by lhasley's
#			paper tape reader.   Has additional error checks since specific format is known
# PTW:	ascii file, drum words.  29-bit words extracted from the tape symbols
#  			<block> <word time>  <word contents>
# PTR:  Binary file, Column reversed PT file format
# V:	Verilog, tape contents expressed as a long array to drive a Verilog emulation/FPGAs.
# DIS:	Disassembler.   
#			provides a per word back to machine source of the PTW format
#
# Note: DIS will soon be replaced with a more intelligent version that traces through
# the code, similar to what actual G15s do.  This new format was conceived by 
# Rob Kolstad
#
# Note: these formats are adaptations of nearly identical formats of the
# batch of tapes received from David Green with the Australian computer 
# museum.
#
#
####################################################
#
# class uses Blocks as its main database
# Blocks are nested lists corresponding to the blocks and the WORDS on the tape
#
# usual flow is to read an acquired tape image in binary format
# symbols from the tape are stored in self.Image
# the image is then checked for known errors and corrected if necessary
#   (at present time:  column reversal)
# Blocks[0] is checked to determine if it is NT and a flag is set
#
# once a tape is read, self.Image is replaced with a corrected one:
#   12"         leader and trailer
#   6"          trailer after each stop code
#   1 symbol    after each reload code
#   2" guanrantee   leader placed in front of stop codes, if previous one is too close
#
#
# once a tape is read a variety of "tape" formats may be generated
# including:
#       disassembly listing
#       synthesizable verilog
#       corrected binary image
#

import sys


class PaperTape:
	def __init__(self):

		self.debug = 0

		self.PT_LEADER = 120				# 12" of leader
		self.PT_TRAILER = 120				# 12" of trailer
		self.PT_RELOAD_GUANRANTEE = 20		# interval between reload/STOPS
		self.PT_RELOAD_PAUSE = 1			# number of blanks after a reload
		self.PT_STOP_GAP = 60				# 6" gap after a stop code

		self.PT_MINUS = 0x1
		self.PT_CR = 0x2
		self.PT_TAB = 0x3
		self.PT_STOP = 0x4
		self.PT_RELOAD = 0x5
		self.PT_PERIOD = 0x6
		self.PT_WAIT = 0x7
		self.PT_SPACE = 0x0

		# generate dict of mapping from ascii tape symbols to bendix g15 binary values
		#               0123456789abcdef0123456789abcdef
		self.BIN2PTI = " -CTS/.Wiiiiiiii0123456789uvwxyz"
		self.PTI2BIN = {}
		for i in range(len(self.BIN2PTI)):     
			if self.BIN2PTI[i] != 'i':			# i indicates ignore
				self.PTI2BIN[self.BIN2PTI[i]] = i
		self.PTI2BIN["R"] = self.PTI2BIN["/"]			# permit / in addition to R
		self.PTI2BIN["D"] = self.PTI2BIN["C"]			# permit C in addition to D
		self.PTI_EOLs = {'R':1, '/':1, 'S':1, 'D':1}	# end of line must be one of these in PTI files
		self.PTI_MIN_LINE_LENGTH = 27					# minimum num of chars on a line to not be a fragment
		self.PTI_MAX_LINE_LENGTH = 37					# minimum num of chars on a line to not be a fragment

		self.MAXTAPESIZE = (2 << 15) - 2

	#########################################
	# Blocks to image creation
	#
	# takes word information, creats a symbol stream
	# with appropriate space (timing) characters
	#
	# uses G15 standard (undocumented) format
	# 28 symbols - reload or stop  
	# (no sign char)
	#
	#########################################

	def CreateImage(self, block):
		self.Image = []
		
		self.CI_Fill(self.PT_LEADER)   #  12 inches of leader
		LastReloadLocation = self.CI_CurrentLocation()

		if True:
			len_mod_4 = len(block) % 4
			if len_mod_4 != 0:
				# oops, not quad word aligned
				for i in range(4 - len_mod_4):
					block.append(0)

			# add the data
			quadword = 0
			count = 0
			length = len(block)
			for word in reversed(block):
				word &= (1 << 29) - 1
				quadword <<= 29
				quadword |= word

				if (count % 4) == 3:
					# have a complete quadword
					self.CI_AddQuad(quadword)
					quadword = 0
					#
					# terminate quadword
					#
					# guanrantee minimum RELOAD spacing for M23
					current_loc = len(self.Image)
										
					fill_need = (LastReloadLocation + self.PT_RELOAD_GUANRANTEE) - current_loc
					self.CI_Fill(fill_need)

					# place reload, stop on last
					if count == (length - 1):
						self.Image.append(self.PT_STOP)
						LastReloadLocation = self.CI_CurrentLocation()
						self.CI_Fill(self.PT_STOP_GAP)
					else:
						self.Image.append(self.PT_RELOAD)
						LastReloadLocation = self.CI_CurrentLocation()
						self.CI_Fill(self.PT_RELOAD_PAUSE)

				count += 1

		self.CI_Fill(self.PT_TRAILER)   #  12 inches of trailer

		if len(self.Image) > self.MAXTAPESIZE:
			print('ERROR: Exceeded max tape size: ',self.MAXTAPESIZE)

		return self.Image
			
	def CI_Fill(self, amt):
		if amt > 0:
			self.Image.extend( [self.PT_SPACE] * amt)
			
	def CI_CurrentLocation(self):
		return len(self.Image)

	def CI_AddQuad(self, quadword):
		# add the data symbols for the quadword
		for i in range(112,-1,-4):
			nibble = (quadword >> i) & 0xf
			self.Image.append( nibble | 0x10)


def CreatePti(self):
	pti = []

	outstr = ''
	for sym in self.Image:
		if sym == 0:  # no spaces in PTI unless we deliberately put them there
			continue
		c = self.BIN2PTI[sym]

		# lines begin with space or -
		flag = 0
		if c != '-':
			if len(pti) == 0:
				flag = 1
			if pti[:-1] == '\n':
				flag = 1
			if flag:
				pti.append(' ')

		pti.append(c)
		if c == 'R' or c == 'S' or c == '/':
			pti.append('\n')
			outstr = ''
		if c == 'S':
			pti.append('\n')

	return pti
