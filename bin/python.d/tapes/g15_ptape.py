##############################################
#
# collections of routines to read/write various G15
# tapes in a variety of formats.
#
# At the start of this endeavor not a lot of G15 programs are
# available.  These routines were created to support the 
# addition of programs/tapes, as they are acquired, and placed
# into the tape "database"
#
# the database is a collection of tapes in PTR format
# (see below).
# 
# In addition, a couple of readers have been built to read
# the paper tapes.
#
# Various scripts have been written to perform tape format
# conversions.  These scripts call this class's methods to
# effect the actual read or writing of a particular format
#
#
###############################################
# sources of paper tapes:
# as of this writing (07/31/2022), tape images have been
# acquired from the following sources:
#
# Australian computer museum (via David Green)
# Living Computer Museum (LCM)
# Pierce Fuller website
# Lloyd Hasley personal collection
#
# each of these sources has "artifacts"/features to be dealt with
# Once dealt with, a "master" PTR file is created and becomes
# the official version
#
# Note: Bendix programs tended to change over time.  We have three
# different versions of test routines 1 & 2.  Very similar, but various
# blocks of tape have been upgraded over time.   Knowledge of which one
# is newest and oldest has long since been lost.  Because of this,
# a tape is prefixed with its source location to keep all the names unique
#
####################################################
#
# Tape formats.
#
# M:	music format
#			each line corresponds to a note(2) in time
#			format:   note1 note2 duration
#			see music program UP41 for note and duration codes
# PT:	binary file, one byte per character on the tape.
#			if generated by this program, proper G15 spacing in corporated
#			(see below)
# PTI:	ascii file, one byte per character on tape, expressed in ascii with
#			bendix control characters also mapped to special ascii characters
#			(This file does not preserve any Bendix timing requirements.)
# PTIR:	ascii file, nearly identical to PTI; but assumes the format produced by lhasley's
#			paper tape reader.   Has additional error checks since specific format is known
# PTW:	ascii file, drum words.  29-bit words extracted from the tape symbols
#  			<block> <word time>  <word contents>
# PTR:  Binary file, Column reversed PT file format
# V:	Verilog, tape contents expressed as a long array to drive a Verilog emulation/FPGAs.
# DIS:	Disassembler.   
#			provides a per word back to machine source of the PTW format
#
# Note: DIS will soon be replaced with a more intelligent version that traces through
# the code, similar to what actual G15s do.  This new format was conceived by 
# Rob Kolstad
#
# Note: these formats are adaptations of nearly identical formats of the
# batch of tapes received from David Green with the Australian computer 
# museum.
#
#
####################################################
#
# class uses Blocks as its main database
# Blocks are nested lists corresponding to the blocks and the WORDS on the tape
#
# usual flow is to read an acquired tape image in binary format
# symbols from the tape are stored in self.Image
# the image is then checked for known errors and corrected if necessary
#   (at present time:  column reversal)
# Blocks[0] is checked to determine if it is NT and a flag is set
#
# once a tape is read, self.Image is replaced with a corrected one:
#   12"         leader and trailer
#   6"          trailer after each stop code
#   1 symbol    after each reload code
#   2" guanrantee   leader placed in front of stop codes, if previous one is too close
#
#
# once a tape is read a variety of "tape" formats may be generated
# including:
#       disassembly listing
#       synthesizable verilog
#       corrected binary image
#

import sys
import re

sys.path.insert(0,'./scripts')

from g15_ptape_subr import g15_ptape_subr
from g15_ptape_verilog import g15_ptape_verilog
from g15_ptape_dis import g15_ptape_dis


class PaperTape(g15_ptape_subr, g15_ptape_verilog, g15_ptape_dis):
	def __init__(self):
		g15_ptape_subr.__init__(self)
		g15_ptape_verilog.__init__(self)
		g15_ptape_dis.__init__(self)
		self.debug = 0

		self.PT_LEADER = 120				# 12" of leader
		self.PT_TRAILER = 120				# 12" of trailer
		self.PT_RELOAD_GUANRANTEE = 20		# interval between reload/STOPS
		self.PT_RELOAD_PAUSE = 1			# number of blanks after a reload
		self.PT_STOP_GAP = 60				# 6" gap after a stop code
		self.PT_REVERSE_MAP = self.GenColReverseMap()
		
		# generate dict of mapping from ascii tape symbols to bendix g15 binary values
		#               0123456789abcdef0123456789abcdef
		self.BIN2PTI = " -CTS/.Wiiiiiiii0123456789uvwxyz"
		self.PTI2BIN = {}
		for i in range(len(self.BIN2PTI)):     
			if self.BIN2PTI[i] != 'i':			# i indicates ignore
				self.PTI2BIN[self.BIN2PTI[i]] = i
		self.PTI2BIN["R"] = self.PTI2BIN["/"]		# permit / in addition to R
		self.PTI2BIN["D"] = self.PTI2BIN["C"]		# permit C in addition to D
		self.PTI_EOLs = {'R':1, '/':1, 'S':1, 'D':1}# end of line must be one of these in PTI files
		self.PTI_MIN_LINE_LENGTH = 27				# minimum num of chars on a line to not be a fragment
		self.PTI_MAX_LINE_LENGTH = 37				# minimum num of chars on a line to not be a fragment
		
		# note: max tape size comes from verilog model which has a 15bit position counter
		# 32K symbols is greater than any known tape
		# 21440 symbols is sufficient to fill entire g15 drum
		self.MAXTAPESIZE = (2<<15) -2
		
		self.tape = {}
		self.Blocks = []		# main database, list of list;  29bit words 
		self.Image = []			# consecutive symbol list (flat), entire tape
		self.NumberTrack = self.CreateNumberTrack()
		self.Block0IsNumberTrack = False

		self.hex2ascii = "0123456789uvwxyz"

		# music program
		self.note_chars = { "r":0, 'b0"':1, 'c':2, 'd':3, 'e':4, 'f':5, 'f#':6, 'g':7,
							'a':8, 'bf':9, 'b':10, "c'":11, "c#'":12, "d'":13, "e'":14, "f'":15 }
		self.notes = []
		for key, value in self.note_chars.items():
			self.notes.append(key)
		self.note_durations = "0123456789uvwxyz"
		self.signstr = ' -'

	def Update(self):
		self.CheckIfNumberTrack()			
		self.CreateImage()
	
	def GenColReverseMap(self):
		map = []
		for i in range(32):
			reversed = 0
			byte = i
			for j in range(5):
				reversed = (reversed << 1) | (byte & 1)
				byte >>= 1
			#print("table gen i=%02x"%i, ' rev=%02x'%reversed)
			map.append(reversed)
		return map
		
	#########################################
	# NT routines
	#########################################

	def CreateNumberTrack(self):
		nt = []
		word = 0x10000000
		for i in range(1,108):
			word += 0x202000
			nt.append(word)
		nt.append(0x2828f29)

		if self.debug & 1:
			self.PrintPtrwBlock(sys.stdout, nt, 99)

		return nt
		
	def	CheckIfNumberTrack(self):
		if len(self.Blocks) > 0:
			self.CheckBlockIfNumberTrack( self.Blocks[0] )
		else:
			self.Block0IsNumberTrack = False		

	def CheckBlockIfNumberTrack(self, block):
		if len(block) != 108:
			return False

		for i in range(108):
			if( block[i] != self.NumberTrack[i]):
				self.Block0IsNumberTrack = False
				return False

		self.Block0IsNumberTrack = True
		return True

	def PrependNumberTrack(self):
		print('Note: Prepending number track')

		self.Blocks.insert(0, self.NumberTrack)
		self.Update()

	#########################################
	# M (music) FORMAT routines
	#########################################

	def ReadM(self, file):
		try:
			if file == sys.stdin:
				fin = sys.stdin
			else:
				fin = open(file,"r")
		except:
			print('Error: Cannot read m file: ', file)
			sys.exit(1)

		file_contents = fin.readlines()
		file_contents.append("")
		fin.close()

		self.Blocks = []
		block = []
		for line in file_contents:
			line = line.strip()

			# line comments
			ii = line.find('#')
			if ii != -1:
				line = line[:ii]
				if len(line) == 0:
					continue	# ignores lines if comments made them blank

			line_lower = line.lower()
			tokens = line_lower.split()
			l = len(tokens)
			if l == 0:
				# empty line, not caused by comments
				if len(block):
					self.Blocks.append(block)
					block = []
				continue
			elif l == 1:
				# compressed format: matches Bendix documentation
				sign = 0
				if tokens[0][0] == '-':
					sign = 1
					tokens[0] = tokens[0][1:]
				value = self.str2word(tokens[0])
				value <<= 1
				value |= sign
				block.append(value)
				continue
			elif l == 2:
				# single note uncompressed
				tokens.insert(1, "r")

			# token count == 3
			try:
				sign = 0
				if tokens[1][0] == '-':
					sign = 1
					tokens[1] = tokens[1][1:]
				value = self.note_chars[tokens[0]] << 8
				value |= self.note_chars[tokens[1]] << 4
				value |= self.note_durations.index(tokens[2])
				value <<= 1
				value |= sign
			except:
				print("ERROR: Unknown note spec:", tokens)
				value = 0
			block.append(value)

		if len(block):
			self.Blocks.append(block)

		self.Update()

	def WriteM(self, file, compressed=1):
		# write a music program ascii data file
		try:
			if file == sys.stdout:
				fout = sys.stdout
			else:
				fout = open(file, "w")
		except:
			print('Error: Cannot write m file: ', file)
			sys.exit(1)

		blockCount = 0
		for block in self.Blocks:
			wordTime = 0
			print('#Song Number: %d' % blockCount, file=fout)
			for word in block:
				sign = word & 1
				a = (word >> 9) & 0xf
				b = (word >> 5) & 0xf
				c = (word >> 1) & 0xf
				if compressed:
					outstr = self.signstr[sign] + self.hex2ascii[a] + self.hex2ascii[b] + self.hex2ascii[c]
					print(outstr, file=fout)
				else:
					if sign:
						signstr = '-'
					else:
						signstr = ''
					c_str = self.note_durations[c]

					print(self.notes[a] + '\t' + signstr + self.notes[b] + '\t' + c_str, file=fout)
				wordTime += 1
			blockCount += 1

		if fout != sys.stdout:
			fout.close()

	#########################################
	# PT FORMAT routines
	#########################################

	def ReadPt(self, file):
		try:
			with open(file, 'rb') as f:
				Bytes = f.read()			# read the entire file
		except:
			print('Cannot open file: ', file)
			Bytes = []

		for byte in Bytes:
			self.Image.append(byte)
#			self.Image.append(ord(byte))
			
		self.ReverseImage()					# correct column reversal, if needed
		self.ExtractBlocksFromImage()
		self.Update()

		return self.Image		
		
	def	ReverseImage(self):
		# some tapes have the columns reversed
		# detect if reverse and correct if necessary
		
		count0 = 0
		count4 = 0
		for byte in self.Image:
			if byte&1:
				count0 += 1
			if byte & 0x10:
				count4 += 1
			
		if count0 > count4:
			print('Note: tape columns are reversed, repairing image....')

			newImage = []
			for byte in self.Image:
				#print("byte=%02x"%byte, ' rev=%02x'%self.PT_REVERSE_MAP[byte])
				newImage.append(self.PT_REVERSE_MAP[byte])
			self.Image = newImage
	
	def ReverseColumns(self):
		newImage = []
		for byte in self.Image:
			#print("byte=%02x"%byte, ' rev=%02x'%self.PT_REVERSE_MAP[byte])
			newImage.append(self.PT_REVERSE_MAP[byte])
		self.Image = newImage
			
	def	ExtractBlocksFromImage(self):
		tape_blocks = []

		block = []
		databuffer = 0
		sign = 0
		garbageFlag = 0
		for bytec in self.Image:
			# byte = ord(bytec)
			byte = bytec
			if byte & 0x10:
				# data byte
				databuffer = databuffer << 4
				databuffer = databuffer & ((1<<(29*4))-1)
				databuffer = databuffer | (byte & 0xf)
			elif byte == 0x1:
				# sign bit
				sign = 1;
			elif (byte == 2) or (byte == 3):
				# CR or TAB
				databuffer = databuffer << 1
				databuffer = databuffer & ((1<<(29*4))-1)
				databuffer = databuffer | sign			
				sign = 0
			elif byte == 4:
				# STOP (reload + end of block)
				block = self.SplitQuadWord(databuffer, block)
				databuffer = 0
				tape_blocks.append(block)
				block = []
			elif byte == 5:
				# Reload
				block = self.SplitQuadWord(databuffer, block)
				databuffer = 0
			elif byte == 6:
				# Period		
				continue
			elif byte == 7:
				# wait
				# equivalent to a data zero
				databuffer = databuffer << 4
			elif byte == 0:
				# space
				# ignore
				continue
			else:
				print('garbage byte: 0x%02x'%byte)
				garbageFlag = 1

		if garbageFlag :
			print('Note: invalid characters were detected in the tape image')

		self.Blocks += tape_blocks		# add to blocks (permits incremental reads)
					
	def SplitQuadWord(self, quadword, block ):
		# split a 29*4 bit quad word into its individual 29 bit words
		mask = (1<<29) - 1
	
		words = []
		for i in range(4):
			word = quadword & mask
			quadword = quadword >> 29
			words.append(word)
		
		for i in range(3,-1,-1):
			block.insert( 0, words[i] )
			
		return block

	def WritePt(self, file, reverse=False):
		# write a pt binary file

		# create binary database from the word database (w headers/trailers)
		self.CreateImage()

		if reverse:
			self.ReverseColumns()

		try:
			if file == sys.stdout:
				fout = sys.stdout
			else:
				fout = open(file, "wb")
		except:
			print('Error: Cannot write pt file: ', file)
			sys.exit(1)

		fout.write( bytearray( self.Image ) )

		if fout != sys.stdout:
			fout.close()

	#########################################
	# PTI FORMAT routines
	#
	# note:
	# a tape is normally spread across multiple PTI files
	# so a read is an incremental.
	#########################################
	
	def ReadPti(self, file):		
		try: 
			if file == sys.stdin:
				fin = sys.stdin
			else:
				fin = open(file, "r")
		except:
			print('ERROR: Cannot open paper tape file: ', file, ' for reading')
			return

		image = []
		errflag = 0
		for line in fin:
			line = line.strip()
			line = line.replace("@---@","")
			line = line.replace("@","")
			
			comment = line.find("#")
			if comment != -1:
				line = line[:comment]
			
			if self.debug & 2:
				print('line=',line)	
				
			ll = len(line)
			if ll == 0:
				continue		# ignore empty lines
				
			if ll < self.PTI_MIN_LINE_LENGTH:
				errflag += 1
				print("Warning line length, length= ", ll, " line ignored: ", line)
				continue		# ignore line fragments	
		
			if line[-1] not in self.PTI_EOLs:
				errflag += 1
				print("Error: invalid end of line char, line ignored: ", line)
				continue
				
			for c in line:
				if c in self.PTI2BIN:
					image.append(self.PTI2BIN[c])
				else:
					print("Error: Invalid char: ", c, " in line: ", line)
					errflag += 1
	
		# extract 29-bit words from tape image
		self.Image = image
		self.ExtractBlocksFromImage()
		self.Update()
				
		if fin != sys.stdin:
			fin.close()

	def WritePti(self, file):
		# write a pti file
		try:
			if file == sys.stdout:
				fout = sys.stdout
			else:
				fout = open(file,"w")
		except:
			print("Error: Unable to open file: ", file, " for writing")
			sys.exit(1)
			
		outstr = ''
		for sym in self.Image:
			if sym == 0:			# no spaces in PTI unless we deliberately put them there
				continue
			c = self.BIN2PTI[sym]

			# lines begin with space or -			
			if outstr == '' and c != '-':
				outstr = ' '
			
			outstr += c
			if c == 'R' or c == 'S' or c == '/':
				print(outstr, file=fout)
				outstr = ''
			if c == 'S':
				print('', file=fout)			
		
		if fout != sys.stdout:
			fout.close()
				

	#########################################
	# PTW FORMAT routines
	#########################################

	def WritePtw(self, file):
		# write a ptw file

		try:
			if file == sys.stdout:
				fout = sys.stdout
			else:
				fout = open(file, "w")
		except:
			print('Error: Cannot write file: ', file)
			sys.exit(1)
		
		if self.CheckIfNumberTrack():
			print("# Block 0 is number Track", file=fout)

		self.PrintPtw(fout)

		if fout != sys.stdout:
			fout.close()

	def ReadPtw(self, file):
		try:
			if file == sys.stdin:
				fin = sys.stdin
			else:
				fin = open(file, "r")
		except:
			print('Error: Cannot open ptw file: ', file)
			sys.exit(1)

		contents = []
		block = []
		current_block = -1
		for line in fin.readlines():

			# process comments
			ii = line.find("#")
			if ii != -1:
				line = line[:ii]

			# tokenize
			tokens = line.split()

			ll = len(tokens)
			if ll == 0:
				continue
			elif ll != 3:
				# error
				print('Error: Ptw format error: line: ',line)
				continue

			block_str = tokens[0]
			address_str = tokens[1]
			data_str = tokens[2]

			if current_block != block_str:
				# end of block
				if len(block) != 0:
					# if current/old block is not empty, capture it
					self.Blocks.append(block)
					block = []

				current_block = block_str

			# same block
			address = self.sexDecStr2data(address_str)

			if address != len(block):
				print('Error: ptw format error, address is not sequential')
				continue

			if data_str[0] == '-':
				neg = 1
				data_str = data_str[1:]
			else:
				neg = 0
				
			data = self.str2word(data_str)
			data = (data << 1) | neg
			block.append(data)

			if self.debug & 1:
				print('datastr=', data_str, ' data=0x%08x'%data)

		# EOF
		if len(block) != 0:
			self.Blocks.append(block)

		if file != sys.stdin:
			fin.close()
	
		# check if number track, create image		
		self.Update()
		
	def PrintPtw(self, fout):
		blockCount = 0
		for block in self.Blocks:
			self.PrintPtrwBlock(fout, block, blockCount)
			blockCount += 1

	def PrintPtrwBlock(self, fout, block, blockCount):
		wordTime = 0
		for word in block:
			#print('%02d' % blockCount, ' %s' % self.data2sexDecStr(wordTime), '%s' % self.word2str(word), file=fout)
			print('%02d' % blockCount, ' %s' % self.data2sexDecStr(wordTime), '%s' % self.SexOutString(word), file=fout)

			wordTime += 1

		print("", file=fout)		
			
	#########################################
	# PTIR FORMAT routines
	# PTIR = PTI RAW file from tape reader
	#
	# same as PTI format, but with specific error checks
	# creates binary image (without spaces) here and then
	# calls main routines to parse up image
	#########################################

	def ReadPtir(self,file, strict=1):
		validLineLengths = [29, 31,33]
		
		try:
			f = open(file, 'r')
		except IOError:
			print('Cannot open file: ', file)
			self.Image = []
			return self.Image
		
		errcount = 0
		warningcount = 0
		charSinceReload = 0
		quadsSinceStop = 0
		numBlocks = 0
		lineNumber = 0
		for line in f.read().splitlines():
			lineNumber += 1
			
			# make pass through file performing error checks
			# if line passes, append to history

			# check if runt line
			lineLength = len(line)
			if lineLength<3:			# have a line fragment
				# just ignore, no message
				continue
				
			# process comments, look for rob's data fields
			if True:
				if line.find('#') != -1:
					# have a line with comment					
					tokens = line.split()
					if tokens[0] != '#':
						continue		# unknown, eat line
					
					ii = line.find(":")
					if ii == -1:
						continue
					value = line[ii+2:]
					
					if tokens[1] == 'File':
						value = value.replace(" ","")
						self.tape['filename'] = value
					elif tokens[1] == 'Short':
						self.tape['short'] = value
					elif tokens[1] == 'Date':
						self.tape['date'] = value
					elif tokens[1] == 'Notes':
						self.tape['notes'] = value
					elif tokens[1] == 'Operator':
						self.tape['operator'] = value
					elif tokens[1] == 'Provenance':
						self.tape['provenance'] = value
					elif tokens[1] == 'block:':
						continue		# eat
					elif tokens[1] == 'checksum:':
						self.tape['checksum'] = value
					continue
				
			# specials
			if True:
				# ignore lines that begin with
				if line.startswith(('G15', 'no errors detected', 'loop:', 'Error: Line')):
					continue
									
			# check line length
			if lineLength < self.PTI_MIN_LINE_LENGTH:
				print('Warning: line too short (ignored): ', line)
				warningcount += 1
				continue

			#if lineLength not in validLineLengths:
			if lineLength > self.PTI_MAX_LINE_LENGTH:
				print('Warning: Unexpected line length: ', lineLength)
				#print('\tExpected values are: ', validLineLengths)
				print('\tline ignored: ', line)
				warningcount += 1					
				continue

			# check beginning of line
			if strict:
				if line[0] != ' ' and line[0] != '-':
					print("Error: Strict: line start char, line: ", line)
					errcount += 1
					continue
			
			# check end of line
			if line[-1] not in self.PTI_EOLs:
				print("Warning: line end char, line ignored: ", line)
				warningcount += 1
				continue

			# NEED TO HAVE ONLY VALID LINES before processing bytes in the lines
			# perform checks on the bytes across the entire line				
			for byte in line:
				if charSinceReload > 100:
					print('Error:  too many symbols since reload')
					errcount += 1
			
				if byte not in self.PTI2BIN:
					print('Error, unknown tape symbol: ', byte, ' line: ', line)
					errcount += 1
					continue
					
				# have valid character, map to g15 binary
				binary = self.PTI2BIN[byte]				
				if binary == 5:
					# reload	
					quadsSinceStop += 1
					charSinceReload = 0
					
					if quadsSinceStop > (108/4):
						print('Error:  too many quadwords since stop')
						errcount += 1					
					
				elif binary == 4:
					# stop
					quadsSinceStop = 0
					charSinceReload = 0
					numBlocks += 1				
				else:
					charSinceReload += 1
				
				self.Image.append(binary)
						
		print('Note: ', numBlocks, ' tape blocks detected')
		print('Total ', warningcount, ' Warnings detected')
		if errcount:
			print('Total ', errcount, ' Errors detected')
			sys.exit(1)
			
		self.ExtractBlocksFromImage()
		self.Update()
				
		return self.Image		
			
	#########################################
	# Blocks to image creation
	#
	# takes word information, creats a symbol stream
	# with appropriate space (timing) characters
	#
	# uses G15 standard (undocumented) format
	# 28 symbols - reload or stop  
	# (no sign char)
	#
	#########################################

	def CreateImage(self):
		self.Image = []
		
		self.CI_Fill(self.PT_LEADER)   #  12 inches of leader
		LastReloadLocation = self.CI_CurrentLocation()

		for block in self.Blocks:
			len_mod_4 = len(block) % 4
			if len_mod_4 != 0:
				# oops, not quad word aligned
				block.append( [0] * (4 - len_mod_4))

			# add the data
			quadword = 0
			count = 0
			length = len(block)
			for word in reversed(block):				
				word &= (1 << 29) - 1
				quadword <<= 29
				quadword |= word

				if (count % 4) == 3:
					# have a complete quadword
					self.CI_AddQuad(quadword)
					quadword = 0
					#
					# terminate quadword
					#
					# guanrantee minimum RELOAD spacing for M23
					current_loc = len(self.Image)
										
					fill_need = (LastReloadLocation + self.PT_RELOAD_GUANRANTEE) - current_loc
					self.CI_Fill(fill_need)

					# place reload, stop on last
					if count == (length - 1):
						self.Image.append(self.PT_STOP)
						LastReloadLocation = self.CI_CurrentLocation()
						self.CI_Fill(self.PT_STOP_GAP)
					else:
						self.Image.append(self.PT_RELOAD)
						LastReloadLocation = self.CI_CurrentLocation()
						self.CI_Fill(self.PT_RELOAD_PAUSE)

				count += 1

		self.CI_Fill(self.PT_TRAILER)   #  12 inches of trailer

		if len(self.Image) > self.MAXTAPESIZE:
			print('ERROR: Exceeded max tape size: ',self.MAXTAPESIZE)
			
	def CI_Fill(self, amt):
		if amt > 0:
			self.Image.extend( [self.PT_SPACE] * amt)
			
	def CI_CurrentLocation(self):
		return len(self.Image)

	def CI_AddQuad(self, quadword):
		# add the data symbols for the quadword
		for i in range(112,-1,-4):
			nibble = (quadword >> i) & 0xf
			self.Image.append( nibble | 0x10)

	###########################################
	#
	# calculate block chksums
	#
	############################################

	def SexOutString(self, num):
		ans = '-' if num&1 else ' ';
		ans += '.'
		ans += self.data2str(num>>1, 28)
		return ans

	def TwosComplement (self, x):
		# return g15 2s complement of 29 bit signed word
		if (x & 1) == 0:		# positive number
			return x
		x = - (x >> 1)
		return ( (x<<1) & 0x1FFFFFFF ) | 1

	def CheckSum(self, outfile):

		try:
			if outfile == sys.stdout:
				fout = sys.stdout
			else:
				fout = open(outfile, "w")
		except:
			print('Error: Cannot write file: ', outfile)
			sys.exit(1)

		print('Block\tSum', file=fout)
		l = len(self.Blocks)
		for blockid in range(l):
			block = self.Blocks[blockid]
			
			if self.CheckBlockIfNumberTrack(block):
				numberTrackStr = "\tNT"
			else:
				numberTrackStr = ""
						
			sum = 0
			i = 10
			for word in block:
				if word & 1:
					word = ((~word) + 2) & 0x3ffffffe
				if word == 0x20000000:
					word = 0
				sum += word
				sum &= 0x3ffffffe
			if sum & 0x20000000:
				sum = (sum & ~0x20000000) + 1	
						
			print(blockid, '\t', self.SexOutString(sum), numberTrackStr, file=fout)

		if fout != sys.stdout:
			fout.close()
